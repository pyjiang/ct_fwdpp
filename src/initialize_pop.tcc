// initialize pop from parameters
#ifndef _INITIAL_POP_TCC_
#define _INITIAL_POP_TCC_

#include "ct_singlepop.hpp"
#define _CT_SINGLEPOP_



// initialize pop without robust bits, for basic type
template <typename pop_t,
          typename fit_policy>
pop_t initialize_pop( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1, double ga, int type, double theta, const fit_policy & ff)
{

  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the initial genotype of the population, before anything gets fixed)
  Cell_type ct = calc_cell_type_from_para_indeph(nz,Lv,c,pv1,ga,r);

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, ct.z, type, r);

  // a new populatio type that includes everything!

  pop_t pop(N, ff(ct.z, b_vec), ct.wv, b_vec, ct);

  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;
}


// initialize pop, b vector is generated by a random genotype
template <typename pop_t,
          typename fit_policy>
pop_t initialize_pop_b_rand_geno( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1, double ga, double theta, const fit_policy & ff)
{

  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
  // initial robustness is total random (with random bits), and will be used for the initial h
  Cell_type ct = calc_cell_type_from_para_indeph(nz,Lv,c,pv1,ga,r);

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, pv1, ct.w, ct.h,  r); // do not save the genotype for now (may need to output in the future)

  // a new populatio type that includes everything!

  pop_t pop(N, ff(ct.z, b_vec), ct.wv, b_vec, ct);

  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;
}


// added on 2.15.17
// for pop without robust bits , but record mean and sd of selection coef of new mutations
// here initialize with an extra parameter, which determines how many different bits of initial environment b and initial phenotype z
template <typename pop_t,
          typename fit_policy>
pop_t initialize_pop( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1, double ga, int type, double theta, int diffk, const fit_policy & ff)
{

  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
  // initial robustness is total random (with random bits), and will be used for the initial h
  Cell_type ct = calc_cell_type_from_para_indeph(nz,Lv,c,pv1,ga,r);

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, ct.z, type, r, diffk);

  // a new populatio type that includes everything!

  pop_t pop(N, ff(ct.z, b_vec), ct.wv, b_vec, ct);

  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;
}



// // created on 1.23.17
// // initialize population without robust bits
// // initial popultion consists of population with three degrees of robustness
// template <typename pop_t,
//           typename fit_policy>
// pop_t initialize_pop_three_rob( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
//                             double c, double pv1, double ga, int type, double theta, const fit_policy & ff)
// {
//
//   // need to initialize w, v and h.
//   // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
//   // initial robustness is total random (with random bits), and will be used for the initial h
//   Cell_type ct_1 = calc_cell_type_from_para_indeph(nz,Lv,c,pv1,ga,r);
//   Cell_type ct_2 = scaled_ct(ct_1, 0.5);
//   Cell_type ct_3 = scaled_ct(ct_1, 2);
//
//   // generate b vec
//   ArrayXb b_vec(nz); // same size as z vector
//
//   generate_b_vec(b_vec, ct_1.z, type, r);
//
//   uint twoN = 2*N;
//
//   std::vector<Cell_type> ct_vec = {ct_1, ct_2, ct_3};
//   std::vector<uint> ct_vec_count = {twoN/3, twoN/3, twoN-2*twoN/3};
//
//   // for test only
//   // std::cout << ct_vec[0].gamma << ct_vec[1].gamma << ct_vec[2].gamma << std::flush;
//
//   // a new populatio type that includes everything!
//
//   pop_t pop(N, ff(ct_1.z, b_vec), ct_vec, ct_vec_count , b_vec, ct_1);
//
//   pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));
//
//   return pop;
//
// }



// modified on 2.2.17
// add another parameter: normalize_len, regarding the total length that robustness to normalize to. (if one locus: use Lv, if two locus, use robust_bits)
// use scale_flag (inidicating how many degrees of threshold), currently only 3,5,10
// modified on 2.1.17
// remove robust_val parameter (the common genotype will be assigned as 0)
// add a new argument: scale_func_flag
// change the parameter scale_vec into robust_geno vector
// initialize of cell types, different in their scale factor
// but use wij type of gamete
// scale_vec has the vector to scale the initialized cell type
// note: this Lv contains length of both genotype and robust bits
template <typename pop_t,
          typename Robust_Geno_Vec>
          // typename fit_policy>
pop_t initialize_pop_diff_rob( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1, double ga, int type, double theta, uint & robust_degrees, int robust_flag,  uint robust_bits, uint normalize_len ,
                            const Robust_Geno_Vec robust_geno_vec, int scale_flag)
{

  // // note: this part of the code is obselete!! should not use!
  // if (robust_flag==0)
  //   robust_degrees = pow(2,robust_bits);
  // else
  //   robust_degrees = robust_bits +1 ; // modified on 1.31.17



  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
  // initial robustness is total random (with random bits), and will be used for the initial h
  // initial_val (robust genotype) will be stored as 0 for the default genotype
  Cell_type ct_1 = calc_cell_type_from_para_indeph(nz, Lv ,robust_bits,robust_flag,c,pv1, ga, r,0 );


  // Cell_type ct_2 = scaled_ct(ct_1, 0.5);
  // Cell_type ct_3 = scaled_ct(ct_1, 2);

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, ct_1.z, type, r);

  uint twoN = 2*N;

  // initialize count
  uint diff_ct_count = robust_geno_vec.size();
  std::vector<uint> ct_vec_count(diff_ct_count);
  uint sum =0;
  for (uint i =0; i< diff_ct_count-1; i++)
  {
    ct_vec_count[i] = twoN/diff_ct_count ;
    sum += ct_vec_count[i];
  }
  ct_vec_count[diff_ct_count-1] = twoN -sum;

  // for test only
  // std::cout << ct_vec[0].gamma << ct_vec[1].gamma << ct_vec[2].gamma << std::flush;

  // a new populatio type that includes everything!

  // pop_t pop(N, ff(ct_1.z, b_vec), normalize_len, robust_degrees, robust_geno_vec, ct_vec_count ,scale_flag, robust_flag, b_vec, ct_1);

  pop_t pop(N,  normalize_len, robust_degrees, robust_geno_vec, ct_vec_count ,scale_flag, robust_flag, b_vec, ct_1);

  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;

}


// this version should work with given scale_vec
template <typename pop_t,
          typename Scale_Vec,
          typename fit_policy>
pop_t initialize_pop_diff_rob( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1, double ga, int type, double theta, uint & robust_degrees, int robust_flag,  uint robust_bits,
                            const Scale_Vec scale_vec, const fit_policy & ff)
{

  // if (robust_flag==0)
  //   robust_degrees = pow(2,robust_bits);
  // else
  //   robust_degrees = robust_bits +1 ; // modified on 1.31.17

  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
  // initial robustness is total random (with random bits), and will be used for the initial h
  // initial_val (robust genotype) will be stored as 0 for the default genotype
  Cell_type ct_1 = calc_cell_type_from_para_indeph(nz, Lv ,robust_bits,robust_flag,c,pv1, ga, r,0 );


  // Cell_type ct_2 = scaled_ct(ct_1, 0.5);
  // Cell_type ct_3 = scaled_ct(ct_1, 2);

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, ct_1.z, type, r);

  uint twoN = 2*N;

  // initialize count
  uint diff_ct_count = scale_vec.size();
  std::vector<uint> ct_vec_count(diff_ct_count);
  uint sum =0;
  for (uint i =0; i< diff_ct_count-1; i++)
  {
    ct_vec_count[i] = twoN/diff_ct_count ;
    sum += ct_vec_count[i];
  }
  ct_vec_count[diff_ct_count-1] = twoN -sum;

  // for test only
  // std::cout << ct_vec[0].gamma << ct_vec[1].gamma << ct_vec[2].gamma << std::flush;

  // a new populatio type that includes everything!

  // pop_t pop(N, ff(ct_1.z, b_vec), 0, scale_vec, ct_vec_count ,  b_vec, ct_1);

  pop_t pop(N, 0, scale_vec, ct_vec_count ,  b_vec, ct_1);

  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;

}



// to initialize two locus, initial pop with same alpha
// modified on 5.16.17
// ct is initialized as if there is no robustness genotype
// modifed on 2.3.17
// use scale_flag instead of scale_func_flag
// modified on 2.1.17
// added gamma in the parameter, initialize cell type with given gamma
// do not initialize the pop with scale (only with robust_geno)
// modified on 1.31.17
// add a flag indicating which scale function to use
// modified on 1.28.17
// add a scale factor to the initialization
// created on 1.23.17
// to initialize a population with a certain robustness given scale value (robustness don't evolve in this case)
template <typename pop_t,
          typename fit_policy>
pop_t initialize_pop_w_rob_no_h( unsigned N,  const gsl_rng * r, uint32_t nz, uint32_t Lv,
                            double c, double pv1,  double ga,  int type, double theta, double scale, const fit_policy & ff)

{

  // need to initialize w, v and h.
  // ct contains w,v,h,z_val,z ; they represent the reference value (the genotype of the population, before anything gets fixed)
  // initial robustness is total random (with random bits), and will be used for the initial h
  Cell_type ct = calc_cell_type_from_para_indeph(nz, Lv ,c,pv1, ga, r );

  // generate b vec
  ArrayXb b_vec(nz); // same size as z vector

  generate_b_vec(b_vec, ct.z, type, r);

  // a new populatio type that includes everything!

  pop_t pop(N, ff(ct.z,b_vec), scale, ct.wv, b_vec,ct);


  pop.mutations.reserve(size_t(std::ceil(std::log(2*N)*theta+0.667*theta)));

  return pop;
}




#endif
